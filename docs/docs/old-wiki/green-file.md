---
---

# Формат файла растительности уровня .green

:::caution Not (yet) implemented feature

Некоторые функции, описанные в настоящем документе, более не поддерживаются, либо начнут поддерживаться в будущем.

:::

Формат файла бинарный. 

Версия файла определена в дефайне `SX_GREEN_FILE_FORMAT_VERSION` (sxgreen.h), текущий номер: 1.

Файл хранит информацию (основная):
* Количество видов;
* Количество объектов в виде;
* Тип растительности;
* Трансформации объектов;
* Сегменты для каждого вида;
* Ограничивающие объемы;
* Имена (название вида, путь до моделей лодов, маски).

## Содержимое файла

- uint64_t магическое число, которое определено в дефайне `SX_GREEN_MAGIC_NUM` (sxgreen.h) (8 символов `SX_GREEN_MAGIC_WORD` (sxgreen.h));
- uint32_t номер версии формата файла;
- int32_t количество видов растительности;
- Цикл по количеству видов растительности для чтения каждого:
	- int32_t `GREEN_TYPE` (sxgreen.h);
	- int32_t размер строки имени вида;
	- string имя вида;
	- int32_t размер строки маски;
	- string текстура маски вида;
	- int32_t размер строки пути до физической модели;
	- string путь до физической модели (относительный);
	- если `GREEN_TYPE == GREEN_TYPE_GRASS` то операции ниже повторяются 1 раз для одного лода, иначе повторяются 3 раза для трех лодов:
		- int32_t размер строки пути до физической модели;
		- строка пути до физической модели;
	- float3_t минимум модели;
	- float3_t максимум модели;
	- uint32_t количество объектов в массиве;
	- array `CGreenDataVertex` (sxgreen.h) по количеству объектов в массиве;
	- uint32_t количество байт для сегментов (если на этапе загрузки не будет хватать байтов то будет выдана ошибка, если будет больше то сегменты должны считаться нормально, то есть допускается дополнительная запись в конец файла);
	- uint32_t количество сегментов;
	- Сохранение сегментов:
		- float3_t минимум системного объема сегмента;
		- float3_t максимум системного объема сегмента;
		- float3_t минимум облегающего объема сегмента;
		- float3_t максимум облегающего объема сегмента;
		- uint32_t количество объектов в сегменте;
		- int8_t является ли сегмент не конечным;
		- если сегмент не конечный тогда:
			- продолжается информация о сегментах;
		- иначе:
			- массив ID по количеству элементов;
		- затем снова информация о сегментах;

:::note

Так как дерево имеет конечное и определенное количество информации, то дерево не может бесконечно считываться, оно в итоге будет закончено тогда, когда считается последний узел. 

:::
